package socket.nginx;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.Arrays;import java.util.List;import org.apache.commons.lang.StringUtils;import org.apache.log4j.Logger;/** * 执行本地命令 * * @author shenl * */public class CommandUtil {    public static void execCommand(List<String> commend) throws Exception {        execCommand(commend.toArray(new String[] {}));    }    public static void execCommand(String... commend) throws Exception {        ProcessBuilder builder = new ProcessBuilder();        builder.command(commend);        builder.redirectErrorStream(true);        Process p = null;        WatchThread wt = null;        try {            p = builder.start();            boolean finished = false; // Set to true when p is finished            wt = new WatchThread(p);            wt.start();            while (!finished) {                try {                    System.out.println("commond=" + Arrays.toString(commend));                    int waitValue = -1;                    try {                        waitValue = p.waitFor();                    }                    catch (InterruptedException e) {                        e.printStackTrace();                        continue;                    }                    if (waitValue != 0) {                        String error = "执行命令出错:commond=" + Arrays.toString(commend) + ",error=" + wt.getError();                        throw new Exception(error);                    }                    int exitValue = p.exitValue();                    if (exitValue != 0) {                        String error = "执行命令出错:commond=" + Arrays.toString(commend) + ",error=" + wt.getError();                        throw new Exception(error);                    }                    finished = true;                }                catch (IllegalThreadStateException e) {                    Thread.sleep(500);                }            }        }        finally {            if (wt != null) {                wt.setOver(true);            }            if (p != null) {                p.destroy();            }        }    }    /**     * 监控进程，以防子线程的输出流或输入流缓存太小造成死锁，所以必须自己手动清空缓存     *     * @author zhaosf     * @version $Revision: 1.0 $, $Date: Mar 21, 2012 4:12:37 PM $     */    private static class WatchThread extends Thread {        Process p;        boolean over;        String error = "";        public WatchThread(Process p) {            super("命令行调用监控线程");            this.p = p;            over = false;        }        @Override        public void run() {            InputStream in = p.getInputStream();            BufferedReader br = null;            try {                if (p == null || in == null) {                    return;                }                br = new BufferedReader(new InputStreamReader(in));                while (true) {                    if (p == null || over) {                        break;                    }                    StringBuilder sb = new StringBuilder();                    String line;                    while ((line = br.readLine()) != null) {                        if (StringUtils.isNotBlank(line)) {                            if (line.indexOf("ERROR") != -1) {                                sb.append(line);                                System.out.println(line);                            }                            else {                                System.out.println(line);                            }                        }                    }                    if (StringUtils.isNotBlank(sb.toString())) {                        if (StringUtils.isNotBlank(this.error)) {                            this.error += " " + sb.toString();                        }                        else {                            this.error = "信息：" + sb.toString();                        }                    }                }            }            catch (Exception e) {                if (StringUtils.isNotBlank(this.error)) {                    this.error += " " + e.getMessage();                }                else {                    this.error = "信息：" + e.getMessage();                }                System.out.println(e.toString());            }            finally {                try {                    if (null != br) {                        br.close();                    }                    if (null != in) {                        in.close();                    }                }                catch (IOException e) {                    System.out.println(e.toString());                }            }        }        public void setOver(boolean over) {            this.over = over;        }        public String getError() {            return error;        }    }}